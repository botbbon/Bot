#!/usr/bin/env node
// Clean test harness: query Helius RPC for latest creation/pool events per program.
// Loads `.env` so you can set HELIUS_RPC_URL or HELIUS_API_KEY there.
require('dotenv').config();
const axios = require('axios');

const HELIUS_RPC = process.env.HELIUS_RPC_URL || process.env.HELIUS_FAST_RPC_URL || 'https://mainnet.helius-rpc.com/';
const HELIUS_KEY = process.env.HELIUS_API_KEY || process.env.HELIUS_KEY || '';
// Increase defaults for deeper inspection. Can still be overridden via .env
const LIMIT_SIGNATURES = Number(process.env.LIMIT_SIGNATURES || 1000);
const PER_PROGRAM_MAX = Number(process.env.PER_PROGRAM_MAX || 10);

const PROGRAMS = [
  '9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin',
  'whirLbMiicVdio4qvUfM5KAg6Ct8VwpYzGff3uctyCc',
  'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA',
  'MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr',
  'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s',
  '11111111111111111111111111111111',
  'pAMMBay6oceH9fJKBRHGP5D4bD4sWpmSwMn52FMfXEA',
  'JUP6LkbZbjS1jKKwapdHNy74zcZ3tLUZoi5QNyVTaV4',
  'CAMMCzo5YL8w4VFF8KVHrK22GGUsp5VTaW7grrKgrWqK',
  '9H6tua7jkLhdm3w8BvgpTn5LZNU7g4ZynDmCiNN3q6Rp',
  'PERPHjGBqRHArX4DySjwM6UJHiR3sWAatqfdBS2qQJu'
];

// Global RPC stats and simple throttle to avoid bursts
const RPC_STATS = { calls: 0, successes: 0, failures: 0, retries: 0 };
let _lastRpcTime = 0;
const MIN_RPC_INTERVAL_MS = Number(process.env.MIN_RPC_INTERVAL_MS || 30);

async function heliusRpc(method, params) {
  const maxAttempts = 4;
  for (let attempt = 1; attempt <= maxAttempts; attempt++) {
    try {
      // throttle
      const now = Date.now();
      const since = now - _lastRpcTime;
      if (since < MIN_RPC_INTERVAL_MS) await new Promise(r => setTimeout(r, MIN_RPC_INTERVAL_MS - since));
      RPC_STATS.calls++;
      const body = JSON.stringify({ jsonrpc: '2.0', id: 1, method, params });
      const headers = Object.assign({ 'Content-Type': 'application/json' }, HELIUS_KEY ? { 'x-api-key': HELIUS_KEY } : {});
      const res = await axios.post(HELIUS_RPC, body, { headers, timeout: 15000 });
      _lastRpcTime = Date.now();
      // treat 429/5xx as retryable
      const status = res && res.status;
      if (status === 429 || (status >= 500 && status < 600)) {
        throw { retryable: true, status, message: res.statusText || 'server_error' };
      }
      RPC_STATS.successes++;
      return res.data && (res.data.result || res.data);
    } catch (err) {
      RPC_STATS.retries += Math.max(0, attempt - 1);
      // normalize error
      const status = err && err.response && err.response.status;
      const msg = (err && err.message) || (err && err.response && err.response.statusText) || String(err);
      const retryable = (status === 429) || (status >= 500 && status < 600) || (err && (err.code === 'ECONNRESET' || err.code === 'ETIMEDOUT')) || (msg && msg.toLowerCase().includes('rate'));
      if (attempt >= maxAttempts || !retryable) {
        RPC_STATS.failures++;
        return { __error: msg, status: status };
      }
      // exponential backoff with small jitter
      const base = 200; // ms
      const backoff = Math.min(5000, Math.pow(2, attempt) * base) + Math.floor(Math.random() * 200);
      await new Promise(r => setTimeout(r, backoff));
      // retry
    }
  }
  RPC_STATS.failures++;
  return { __error: 'unreachable' };
}

function extractMintsFromTx(tx) {
  const mints = new Set();
  try {
    const meta = tx && (tx.meta || tx.transaction && tx.meta) || {};
    const post = Array.isArray(meta.postTokenBalances) ? meta.postTokenBalances : [];
    const pre = Array.isArray(meta.preTokenBalances) ? meta.preTokenBalances : [];
    for (const b of post.concat(pre)) if (b && b.mint) mints.add(b.mint);
    const inner = (meta && meta.innerInstructions) || [];
    for (const block of inner) {
      const ins = block && block.instructions || [];
      for (const insItem of ins) {
        try {
          const pt = insItem && insItem.parsed && insItem.parsed.info && insItem.parsed.info.postTokenBalances;
          if (Array.isArray(pt)) for (const b of pt) if (b && b.mint) mints.add(b.mint);
        } catch (e) {}
      }
    }
  } catch (e) {}
  return Array.from(mints);
}

function txLooksLikeCreationOrPool(tx) {
  try {
    const meta = tx && (tx.meta || tx.transaction && tx.meta) || {};
    const logMsgs = Array.isArray(meta.logMessages) ? meta.logMessages.join('\n').toLowerCase() : '';
    const keywords = ['initializemint', 'mintto', 'create account', 'initialize account', 'swap', 'addliquidity', 'initializepool', 'createpool'];
    for (const k of keywords) if (logMsgs.includes(k)) return true;
    const msg = tx && (tx.transaction && tx.transaction.message || tx.transaction) || {};
    const instrs = (msg && msg.instructions) || [];
    for (const instr of instrs) {
      const parsedType = (instr && (instr.parsed && instr.parsed.type)) || (instr && instr.type) || '';
      if (!parsedType) continue;
      const pt = String(parsedType).toLowerCase();
      if (pt.includes('initializemint') || pt.includes('mintto') || pt.includes('swap') || pt.includes('addliquidity')) return true;
    }
  } catch (e) {}
  return false;
}

async function analyzeProgram(program) {
  const result = { program, found: [] };
  const sigs = await heliusRpc('getSignaturesForAddress', [program, { limit: LIMIT_SIGNATURES }]);
  if (!Array.isArray(sigs)) { result.error = sigs && sigs.__error ? sigs.__error : 'no-sigs'; return result; }
  for (let i = 0; i < sigs.length && result.found.length < PER_PROGRAM_MAX; i++) {
    const s = sigs[i];
    const signature = s && (s.signature || s.txHash || s.signature);
    if (!signature) continue;
    const tx = await heliusRpc('getTransaction', [signature, { encoding: 'jsonParsed', maxSupportedTransactionVersion: 0 }]);
    if (!tx || tx.__error) continue;
    if (!txLooksLikeCreationOrPool(tx)) continue;
    const mints = extractMintsFromTx(tx);
    const blockTime = (s && (s.blockTime || s.block_time || s.blocktime)) || (tx && tx.blockTime) || null;
    const accounts = [];
    try {
      const msg = tx && (tx.transaction && tx.transaction.message || tx.transaction) || {};
      const keys = msg && (msg.accountKeys || msg.message && msg.message.accountKeys) || tx && tx.accountKeys || [];
      for (const k of keys || []) {
        const pk = (k && (k.pubkey || k)) || k;
        if (!pk) continue;
        accounts.push(pk);
      }
    } catch (e) {}
    result.found.push({ signature, blockTime, mints, accounts, summaryLog: (tx && tx.meta && tx.meta.logMessages && tx.meta.logMessages.slice(0,6)) || [] });
  }
  return result;
}

(async function runAll(){
  console.error('Starting program analysis for', PROGRAMS.length, 'programs -- limit signatures:', LIMIT_SIGNATURES);
  const out = [];
  for (const p of PROGRAMS) {
    process.stderr.write('Analyzing '+p.slice(0,6)+'... ');
    try {
      const r = await analyzeProgram(p);
      out.push(r);
      process.stderr.write('done, found='+(r.found && r.found.length||0)+'\n');
    } catch (e) { process.stderr.write('error\n'); out.push({ program: p, error: String(e) }); }
  }
  console.log(JSON.stringify({ generatedAt: new Date().toISOString(), heliusRpc: HELIUS_RPC, results: out }, null, 2));
})();
